use futures::future::select_all;
use num::Float;
use std::fmt::Display;
use tokio::sync::mpsc::{channel, Receiver, Sender};

use crate::{
    neural_network::nn_trait::NN,
    topology::{bias::Bias, Topology},
};

use super::spiking_neuron::SpikingNeuron;

/// A spiking Neural Network
///
/// Initialize with `from_topology`
///
/// You can send input witht the `send` function and subscribe asynchronously to output using `recv`
pub struct SpikingNeuralNetwork<T>
where
    T: Float + std::ops::AddAssign + Display + Send + Sync + 'static,
{
    input_channels: Vec<Sender<T>>,
    output_channels: Vec<Receiver<T>>,
}

impl<T> NN<T> for SpikingNeuralNetwork<T>
where
    T: Float + std::ops::AddAssign + Display + Send + Sync + 'static,
{
    /// Instantiates a new Neural Network from a `Topology`
    ///
    /// # Safety
    ///
    /// If the Topology is ill-formed, it will result in pointer overflow.
    /// Topologies generated by this crate are guaranteed to be safe.
    unsafe fn from_topology(topology: &Topology<T>) -> SpikingNeuralNetwork<T> {
        let layer_count = topology.layers_sizes.len();
        let sizes = &topology.layers_sizes;
        let mut layer_addresses = vec![0; layer_count];
        let mut neurons_count: usize = 0;
        for i in 0..layer_count {
            layer_addresses[i] = neurons_count;
            neurons_count += sizes[i] as usize;
        }
        let output_size = *sizes.last().unwrap() as usize;
        let mut neurons: Vec<SpikingNeuron<T>> = Vec::with_capacity(neurons_count);
        let mut senders: Vec<Sender<T>> = Vec::with_capacity(neurons_count);
        let mut biases: Vec<Bias<T>> = Vec::with_capacity(neurons_count);
        for _ in 0..neurons_count {
            let (neuron, sender) = SpikingNeuron::new();
            neurons.push(neuron);
            senders.push(sender);
        }
        for _ in 0..neurons_count {
            biases.push(Bias::new_zero());
        }

        for (point, gene_and_bias) in topology.genes_point.iter() {
            if gene_and_bias.genes.is_empty()
                || gene_and_bias
                    .genes
                    .iter()
                    .all(|gene| gene.borrow().disabled)
            {
                continue;
            }
            let neuron_index = layer_addresses[point.layer as usize] + point.index as usize;
            let input_neuron = &mut neurons[neuron_index];
            biases[neuron_index] = gene_and_bias.bias.clone();
            for gene_rc in &gene_and_bias.genes {
                let gene = gene_rc.borrow();
                if gene.disabled {
                    continue;
                }
                let output = &gene.output;
                let index = layer_addresses[output.layer as usize] + output.index as usize;
                let output_channel = &senders[index];
                input_neuron
                    .outputs
                    .push((gene.input_weight, output_channel.clone()));
            }
        }

        let base = output_size as isize - neurons_count as isize;

        for it in (neurons_count - output_size) as isize..neurons_count as isize {
            biases[it as usize] = topology.output_bias[(it + base) as usize].clone();
        }

        neurons
            .iter_mut()
            .zip(biases.iter())
            .for_each(|(neuron, bias)| {
                neuron.threshold_one = bias.bias_input;
                neuron.threshold_two = bias.bias_reset;
                neuron.decay = bias.bias_update;
            });

        let input_size = *sizes.first().unwrap() as usize;
        let input_channels = senders.into_iter().take(input_size).collect();

        let output_channels: Vec<Receiver<T>> = neurons
            .iter_mut()
            .skip(neurons_count - output_size)
            .map(|neuron| {
                let (sdr, rcv) = channel(1);
                neuron.outputs.push((T::one(), sdr));
                rcv
            })
            .collect();

        let net = SpikingNeuralNetwork {
            input_channels,
            output_channels,
        };

        for neuron in neurons {
            neuron.spawn_task();
        }

        net
    }
}

impl<T> SpikingNeuralNetwork<T>
where
    T: Float + std::ops::AddAssign + Display + Send + Sync + 'static,
{
    /// Sends input to the neural network
    ///
    /// Activates one neuron at a time:
    ///
    /// # Params
    ///
    /// `index`: Index of the neuron to activate
    ///
    /// `value`: Activation value for the neuron
    pub async fn send(&mut self, index: usize, value: T) -> Option<()> {
        self.input_channels[index].send(value).await.ok()
    }

    /// Asynchronously subscribe to input from SNN
    ///
    /// Spiking Neural Networks produce output asynchronously, therefore we have to listen to their output to get actions to execute
    ///
    /// # Returns an option containing a tuple of `(index, value)`, if the option is None it means the Neural Network is shut down
    pub async fn recv(&mut self) -> Option<(usize, T)> {
        let futures: Vec<_> = self
            .output_channels
            .iter_mut()
            .map(|rcv| rcv.recv())
            .map(Box::pin)
            .collect();
        let (value, index, _) = select_all(futures).await;
        value.map(|v| (index, v))
    }
}
